// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GenerateTriangles

#include "MarchTables.compute"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
static const int numThreads = 8;

struct Triangle
{
    float3 posA;
    float3 posB;
    float3 posC;
};

//holds the vertices for the marching cubes to elaborate
RWStructuredBuffer<float4> verticesVert4;

// * NOTE *     originally it should have been an append buffer but because
//              of strange floating triangles it has been converted in to a structured buffer

RWStructuredBuffer<Triangle> triangles;

float surfaceLevel;
int levelOfDetail;
int dimensionX;
int dimensionY;
int dimensionZ;

float3 interpolateVerts(float4 v1, float4 v2) {
    float t = min(max(((surfaceLevel - v1.w) / (v2.w - v1.w)),0),1);
    return v1.xyz +t * (v2.xyz-v1.xyz);

}

int indexFromCoord(int x, int y, int z) {
    
    return z * (dimensionX+1) * (dimensionY+1) + y * (dimensionX+1) + x;
}

[numthreads(numThreads,numThreads,numThreads)]
void GenerateTriangles (uint3 id : SV_DispatchThreadID)
{
    //set all the coordinates dependent to the level of detail
    int x = id.x * levelOfDetail;
    int y = id.y * levelOfDetail;
    int z = id.z * levelOfDetail;
    if (x >= dimensionX || y >=dimensionY || z >= dimensionZ) return;

    //get the current cube index in the grid
    int currentIndex = z * (dimensionX) * (dimensionY) + y * (dimensionX) + x;
    
    float4 cubePoints[8] = 
    {
        verticesVert4[indexFromCoord(x, y, z)],
        verticesVert4[indexFromCoord(x+levelOfDetail, y, z)],
        verticesVert4[indexFromCoord(x+levelOfDetail, y, z+levelOfDetail)],
        verticesVert4[indexFromCoord(x, y, z+levelOfDetail)],
        verticesVert4[indexFromCoord(x, y+levelOfDetail, z)],
        verticesVert4[indexFromCoord(x+levelOfDetail, y+levelOfDetail, z)],
        verticesVert4[indexFromCoord(x+levelOfDetail, y+levelOfDetail, z+levelOfDetail)],
        verticesVert4[indexFromCoord(x, y+levelOfDetail, z+levelOfDetail)]
    };

    //get the cube index OF THE MARCH TABLE from the surface levels of the vertices in the current cube
    int cubeIndex = 0;
    if (cubePoints[0].w < surfaceLevel) cubeIndex |= 1;
    if (cubePoints[1].w < surfaceLevel) cubeIndex |= 2;
    if (cubePoints[2].w < surfaceLevel) cubeIndex |= 4;
    if (cubePoints[3].w < surfaceLevel) cubeIndex |= 8;
    if (cubePoints[4].w < surfaceLevel) cubeIndex |= 16;
    if (cubePoints[5].w < surfaceLevel) cubeIndex |= 32;
    if (cubePoints[6].w < surfaceLevel) cubeIndex |= 64;
    if (cubePoints[7].w < surfaceLevel) cubeIndex |= 128;

    //get the triangulation from the math algorithm
    int triangulationCombination[16] = triangulation[cubeIndex];
    int cont = 0;

    //save the triangles generated by the surfaces level
    for(int i = 0; triangulationCombination[i] != -1; i+=3)
    {
        Triangle triangleTarget = (Triangle)0;

        //take the edges of the cube where lies one of the vertex of the triangle
        int indicesA0 = cornerIndexAFromEdge[triangulationCombination[i]];
        int indicesB0 = cornerIndexBFromEdge[triangulationCombination[i]];

        int indicesA1 = cornerIndexAFromEdge[triangulationCombination[i+1]];
        int indicesB1 = cornerIndexBFromEdge[triangulationCombination[i+1]];

        int indicesA2 = cornerIndexAFromEdge[triangulationCombination[i+2]];
        int indicesB2 = cornerIndexBFromEdge[triangulationCombination[i+2]];

        //interpolate the edge points and based on the surface level of the two find the vertex
        float3 point0 = interpolateVerts(cubePoints[indicesA0], cubePoints[indicesB0]);
        float3 point1 = interpolateVerts(cubePoints[indicesA1], cubePoints[indicesB1]);
        float3 point2 = interpolateVerts(cubePoints[indicesA2], cubePoints[indicesB2]);

        //assign the vertex
        triangleTarget.posA = point0;
        triangleTarget.posB = point1;
        triangleTarget.posC = point2;
        //assign the triangle
        triangles[(currentIndex*5)+cont] = triangleTarget;
        cont++;
    }

    //garbage index to be filled and clean
    for(int i = cont; i < 5; i++)
    {
        Triangle triangleTarget = (Triangle)0;

        triangleTarget.posA = float3(0,0,0);
        triangleTarget.posB = float3(0,0,0);
        triangleTarget.posC = float3(0,0,0);

        triangles[(currentIndex*5)+i] = triangleTarget;
    }
    
    
}
